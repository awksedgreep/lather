defmodule Lather.Server.EnhancedWSDLGenerator do
  @moduledoc """
  Enhanced WSDL generator with multi-protocol support.

  Generates comprehensive WSDL documents that include:
  - SOAP 1.1 bindings (primary)
  - SOAP 1.2 bindings (secondary)
  - HTTP/REST bindings (modern alternative)
  - Multiple service endpoints
  - Complete protocol negotiation support

  This creates the layered API approach where clients can choose
  their preferred protocol while maintaining backward compatibility.
  """

  @doc """
  Generates a comprehensive multi-protocol WSDL document.

  ## Options

  * `:protocols` - List of protocols to include (default: `[:soap_1_1, :soap_1_2, :http]`)
  * `:base_path` - Base path for REST endpoints (default: `/api`)
  * `:include_json` - Include JSON content type support (default: `true`)
  * `:documentation_style` - Style of documentation to include (default: `:comprehensive`)
  """
  def generate(service_info, base_url, options \\ []) do
    protocols = Keyword.get(options, :protocols, [:soap_1_1, :soap_1_2, :http])
    base_path = Keyword.get(options, :base_path, "/api")
    _include_json = Keyword.get(options, :include_json, true)

    target_namespace = service_info.target_namespace
    service_name = service_info.name

    """
    <?xml version="1.0" encoding="UTF-8"?>
    <definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
                 xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
                 xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/"
                 xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"
                 xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/"
                 xmlns:tns="#{target_namespace}"
                 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                 targetNamespace="#{target_namespace}">

      <documentation>
        #{service_name} - Multi-Protocol Web Service

        This service supports multiple protocols for maximum compatibility:
        - SOAP 1.1 (Primary - Maximum Compatibility)
        - SOAP 1.2 (Enhanced Error Handling)
        - HTTP/REST (Modern JSON/XML)

        Generated by Lather SOAP Library v#{get_version()}
      </documentation>

    #{generate_types(service_info)}

    #{generate_messages(service_info)}

    #{generate_port_type(service_info)}

    #{generate_bindings(service_info, protocols)}

    #{generate_service(service_info, base_url, base_path, protocols)}

    </definitions>
    """
  end

  # Generate XSD types section with enhanced documentation
  defp generate_types(service_info) do
    if Enum.empty?(service_info.types) do
      ""
    else
      """
      <types>
        <xsd:schema targetNamespace="#{service_info.target_namespace}"
                    elementFormDefault="qualified"
                    attributeFormDefault="unqualified">
      #{Enum.map_join(service_info.types, "\n", &generate_complex_type/1)}
        </xsd:schema>
      </types>
      """
    end
  end

  # Generate enhanced complex type with better documentation
  defp generate_complex_type(type) do
    doc =
      if type.description do
        "\n        <xsd:annotation>\n          <xsd:documentation>#{type.description}</xsd:documentation>\n        </xsd:annotation>"
      else
        ""
      end

    """
        <xsd:complexType name="#{type.name}">#{doc}
          <xsd:sequence>
    #{Enum.map_join(type.elements, "\n", &generate_element/1)}
          </xsd:sequence>
        </xsd:complexType>
    """
  end

  # Generate element with enhanced options
  defp generate_element(element) do
    type_attr = map_elixir_type_to_xsd(element.type)
    min_occurs = if element.required, do: "1", else: "0"
    max_occurs = element.max_occurs || "1"

    doc =
      if element.description do
        "\n              <xsd:annotation>\n                <xsd:documentation>#{element.description}</xsd:documentation>\n              </xsd:annotation>"
      else
        ""
      end

    """
            <xsd:element name="#{element.name}" type="#{type_attr}"
                         minOccurs="#{min_occurs}" maxOccurs="#{max_occurs}">#{doc}
            </xsd:element>
    """
  end

  # Generate messages with enhanced documentation
  defp generate_messages(service_info) do
    service_info.operations
    |> Enum.map_join("\n", &generate_operation_messages/1)
  end

  # Generate input and output messages for an operation with documentation
  defp generate_operation_messages(operation) do
    input_doc =
      if operation.description do
        "\n    <documentation>Request message for #{operation.name}: #{operation.description}</documentation>"
      else
        ""
      end

    output_doc =
      if operation.description do
        "\n    <documentation>Response message for #{operation.name}: #{operation.description}</documentation>"
      else
        ""
      end

    # Handle both input/output and input_parameters/output_parameters field names
    input_params = Map.get(operation, :input, Map.get(operation, :input_parameters, []))
    output_params = Map.get(operation, :output, Map.get(operation, :output_parameters, []))

    """
    <message name="#{operation.name}Request">#{input_doc}
    #{Enum.map_join(input_params, "\n", &generate_message_part/1)}
    </message>

    <message name="#{operation.name}Response">#{output_doc}
    #{Enum.map_join(output_params, "\n", &generate_message_part/1)}
    </message>
    """
  end

  # Generate message part
  defp generate_message_part(param) do
    type_attr = map_elixir_type_to_xsd(param.type)

    """
      <part name="#{param.name}" type="#{type_attr}"/>
    """
  end

  # Generate port type with enhanced documentation
  defp generate_port_type(service_info) do
    """
    <portType name="#{service_info.name}PortType">
      <documentation>
        Port type defining all operations for #{service_info.name}.
        This interface is implemented by all protocol bindings.
      </documentation>
    #{Enum.map_join(service_info.operations, "\n", &generate_port_operation/1)}
    </portType>
    """
  end

  # Generate port type operation with comprehensive documentation
  defp generate_port_operation(operation) do
    description =
      if operation.description do
        "\n      <documentation>#{operation.description}</documentation>"
      else
        ""
      end

    """
      <operation name="#{operation.name}">#{description}
        <input message="tns:#{operation.name}Request"/>
        <output message="tns:#{operation.name}Response"/>
      </operation>
    """
  end

  # Generate multiple protocol bindings
  defp generate_bindings(service_info, protocols) do
    bindings = []

    bindings =
      if :soap_1_1 in protocols do
        [generate_soap_1_1_binding(service_info) | bindings]
      else
        bindings
      end

    bindings =
      if :soap_1_2 in protocols do
        [generate_soap_1_2_binding(service_info) | bindings]
      else
        bindings
      end

    bindings =
      if :http in protocols do
        [generate_http_binding(service_info) | bindings]
      else
        bindings
      end

    Enum.reverse(bindings) |> Enum.join("\n\n")
  end

  # Generate SOAP 1.1 binding (primary protocol)
  defp generate_soap_1_1_binding(service_info) do
    """
    <binding name="#{service_info.name}SOAP11Binding" type="tns:#{service_info.name}PortType">
      <documentation>SOAP 1.1 Protocol Binding - Primary/Legacy Support</documentation>
      <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
    #{Enum.map_join(service_info.operations, "\n", &generate_soap_1_1_operation/1)}
    </binding>
    """
  end

  # Generate SOAP 1.1 operation binding
  defp generate_soap_1_1_operation(operation) do
    soap_action = operation.soap_action || "#{operation.name}"

    """
      <operation name="#{operation.name}">
        <documentation>SOAP 1.1 binding for #{operation.name}</documentation>
        <soap:operation soapAction="#{soap_action}" style="document"/>
        <input>
          <soap:body use="literal"/>
        </input>
        <output>
          <soap:body use="literal"/>
        </output>
      </operation>
    """
  end

  # Generate SOAP 1.2 binding (enhanced protocol)
  defp generate_soap_1_2_binding(service_info) do
    """
    <binding name="#{service_info.name}SOAP12Binding" type="tns:#{service_info.name}PortType">
      <documentation>SOAP 1.2 Protocol Binding - Enhanced Error Handling and Performance</documentation>
      <soap12:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
    #{Enum.map_join(service_info.operations, "\n", &generate_soap_1_2_operation/1)}
    </binding>
    """
  end

  # Generate SOAP 1.2 operation binding
  defp generate_soap_1_2_operation(operation) do
    soap_action = operation.soap_action || "#{operation.name}"

    """
      <operation name="#{operation.name}">
        <documentation>SOAP 1.2 binding for #{operation.name}</documentation>
        <soap12:operation soapAction="#{soap_action}" style="document"/>
        <input>
          <soap12:body use="literal"/>
        </input>
        <output>
          <soap12:body use="literal"/>
        </output>
      </operation>
    """
  end

  # Generate HTTP/REST binding (modern protocol)
  defp generate_http_binding(service_info) do
    """
    <binding name="#{service_info.name}HTTPBinding" type="tns:#{service_info.name}PortType">
      <documentation>HTTP/REST Protocol Binding - Modern JSON/XML Support</documentation>
      <http:binding verb="POST"/>
    #{Enum.map_join(service_info.operations, "\n", &generate_http_operation/1)}
    </binding>
    """
  end

  # Generate HTTP operation binding with JSON and XML support
  defp generate_http_operation(operation) do
    """
      <operation name="#{operation.name}">
        <documentation>HTTP binding for #{operation.name} - Supports JSON and XML</documentation>
        <http:operation location="/#{String.downcase(operation.name)}"/>
        <input>
          <mime:content type="application/json"/>
          <mime:content type="application/xml"/>
        </input>
        <output>
          <mime:content type="application/json"/>
          <mime:content type="application/xml"/>
        </output>
      </operation>
    """
  end

  # Generate service with multiple endpoints
  defp generate_service(service_info, base_url, base_path, protocols) do
    ports = []

    # SOAP 1.1 endpoint (highest priority)
    ports =
      if :soap_1_1 in protocols do
        [generate_soap_1_1_port(service_info, base_url) | ports]
      else
        ports
      end

    # SOAP 1.2 endpoint
    ports =
      if :soap_1_2 in protocols do
        [generate_soap_1_2_port(service_info, base_url) | ports]
      else
        ports
      end

    # HTTP/REST endpoint
    ports =
      if :http in protocols do
        [generate_http_port(service_info, base_url, base_path) | ports]
      else
        ports
      end

    port_list = Enum.reverse(ports) |> Enum.join("\n\n")

    """
    <service name="#{service_info.name}">
      <documentation>
        #{service_info.name} Multi-Protocol Service

        Available Endpoints:
        - SOAP 1.1: Maximum compatibility with legacy systems
        - SOAP 1.2: Enhanced error handling and performance
        - HTTP/REST: Modern JSON/XML API for web applications

        Choose the endpoint that best matches your client capabilities.
      </documentation>

    #{port_list}
    </service>
    """
  end

  # Generate SOAP 1.1 service port
  defp generate_soap_1_1_port(service_info, base_url) do
    endpoint_url = "#{base_url}soap/v1.1/#{service_info.name}"

    """
      <port name="#{service_info.name}SOAP11Port" binding="tns:#{service_info.name}SOAP11Binding">
        <documentation>SOAP 1.1 Endpoint - Use for maximum compatibility</documentation>
        <soap:address location="#{endpoint_url}"/>
      </port>
    """
  end

  # Generate SOAP 1.2 service port
  defp generate_soap_1_2_port(service_info, base_url) do
    endpoint_url = "#{base_url}soap/v1.2/#{service_info.name}"

    """
      <port name="#{service_info.name}SOAP12Port" binding="tns:#{service_info.name}SOAP12Binding">
        <documentation>SOAP 1.2 Endpoint - Enhanced features and error handling</documentation>
        <soap12:address location="#{endpoint_url}"/>
      </port>
    """
  end

  # Generate HTTP/REST service port
  defp generate_http_port(service_info, base_url, base_path) do
    endpoint_url =
      "#{base_url}#{String.trim_leading(base_path, "/")}/#{String.downcase(service_info.name)}"

    """
      <port name="#{service_info.name}HTTPPort" binding="tns:#{service_info.name}HTTPBinding">
        <documentation>HTTP/REST Endpoint - Modern JSON/XML API</documentation>
        <http:address location="#{endpoint_url}"/>
      </port>
    """
  end

  # Enhanced type mapping with better XSD support
  defp map_elixir_type_to_xsd(:string), do: "xsd:string"
  defp map_elixir_type_to_xsd(:int), do: "xsd:int"
  defp map_elixir_type_to_xsd(:integer), do: "xsd:integer"
  defp map_elixir_type_to_xsd(:long), do: "xsd:long"
  defp map_elixir_type_to_xsd(:boolean), do: "xsd:boolean"
  defp map_elixir_type_to_xsd(:decimal), do: "xsd:decimal"
  defp map_elixir_type_to_xsd(:double), do: "xsd:double"
  defp map_elixir_type_to_xsd(:float), do: "xsd:float"
  defp map_elixir_type_to_xsd(:dateTime), do: "xsd:dateTime"
  defp map_elixir_type_to_xsd(:date), do: "xsd:date"
  defp map_elixir_type_to_xsd(:time), do: "xsd:time"
  defp map_elixir_type_to_xsd(:base64Binary), do: "xsd:base64Binary"
  defp map_elixir_type_to_xsd(:anyURI), do: "xsd:anyURI"
  defp map_elixir_type_to_xsd("string"), do: "xsd:string"
  defp map_elixir_type_to_xsd("int"), do: "xsd:int"
  defp map_elixir_type_to_xsd("integer"), do: "xsd:integer"
  defp map_elixir_type_to_xsd("long"), do: "xsd:long"
  defp map_elixir_type_to_xsd("boolean"), do: "xsd:boolean"
  defp map_elixir_type_to_xsd("decimal"), do: "xsd:decimal"
  defp map_elixir_type_to_xsd("double"), do: "xsd:double"
  defp map_elixir_type_to_xsd("float"), do: "xsd:float"
  defp map_elixir_type_to_xsd("dateTime"), do: "xsd:dateTime"
  defp map_elixir_type_to_xsd("date"), do: "xsd:date"
  defp map_elixir_type_to_xsd("time"), do: "xsd:time"
  defp map_elixir_type_to_xsd("base64Binary"), do: "xsd:base64Binary"
  defp map_elixir_type_to_xsd("anyURI"), do: "xsd:anyURI"
  defp map_elixir_type_to_xsd(type) when is_binary(type), do: "tns:#{type}"
  defp map_elixir_type_to_xsd(type), do: "tns:#{type}"

  # Get current library version
  defp get_version do
    case Application.spec(:lather, :vsn) do
      version when is_list(version) -> List.to_string(version)
      _ -> "1.0.0"
    end
  end
end
