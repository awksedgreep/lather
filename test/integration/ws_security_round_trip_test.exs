defmodule Lather.Integration.WSSecurityRoundTripTest do
  @moduledoc """
  End-to-end integration tests for WS-Security authentication.

  These tests verify that WS-Security headers are properly generated by the client,
  transmitted in SOAP requests, and validated by the server.
  """
  use ExUnit.Case, async: false

  # These tests require starting actual HTTP servers
  @moduletag :integration

  alias Lather.Auth.WSSecurity
  alias Lather.Soap.Header

  # Test credentials
  @valid_username "admin"
  @valid_password "secret123"

  # WS-Security namespaces for validation
  @wsse_ns "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
  @wsu_ns "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
  @password_text_type "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"
  @password_digest_type "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest"

  # Configuration storage for validation settings (uses ETS for cross-process access)
  defmodule ValidationConfig do
    @table_name :ws_security_test_config

    def init do
      if :ets.whereis(@table_name) == :undefined do
        :ets.new(@table_name, [:named_table, :public, :set])
      end
      :ok
    end

    def set(mode, opts) do
      init()
      :ets.insert(@table_name, {:config, mode, opts})
    end

    def get do
      init()
      case :ets.lookup(@table_name, :config) do
        [{:config, mode, opts}] -> {mode, opts}
        [] -> {:text_password, []}
      end
    end
  end

  # Custom router that extracts and validates WS-Security headers
  # and processes the SOAP request itself (without forwarding)
  defmodule TestSecurityRouter do
    use Plug.Router

    # WS-Security namespace - defined as module attribute
    @wsse_namespace "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"

    plug :match
    plug :dispatch

    match "/soap" do
      {:ok, body, conn} = read_full_body(conn)

      {validation_mode, opts} = Lather.Integration.WSSecurityRoundTripTest.ValidationConfig.get()

      case validate_ws_security(body, validation_mode, opts) do
        {:ok, _security_info} ->
          # Process the SOAP request and return a success response
          handle_soap_request(conn, body)

        {:error, :missing_security_header} ->
          send_soap_fault(conn, "Client", "wsse:InvalidSecurityToken",
            "Security header is required but was not found")

        {:error, :invalid_credentials} ->
          send_soap_fault(conn, "Client", "wsse:FailedAuthentication",
            "Authentication failed: invalid username or password")

        {:error, :invalid_password_digest} ->
          send_soap_fault(conn, "Client", "wsse:FailedAuthentication",
            "Authentication failed: password digest verification failed")

        {:error, :timestamp_expired} ->
          send_soap_fault(conn, "Client", "wsse:MessageExpired",
            "Message has expired based on timestamp")

        {:error, :missing_timestamp} ->
          send_soap_fault(conn, "Client", "wsse:InvalidSecurityToken",
            "Timestamp is required but was not found")

        {:error, reason} ->
          send_soap_fault(conn, "Client", "wsse:InvalidSecurityToken",
            "Security validation failed: #{inspect(reason)}")
      end
    end

    defp read_full_body(conn, body \\ "") do
      case Plug.Conn.read_body(conn) do
        {:ok, chunk, conn} -> {:ok, body <> chunk, conn}
        {:more, chunk, conn} -> read_full_body(conn, body <> chunk)
        {:error, reason} -> {:error, reason}
      end
    end

    defp handle_soap_request(conn, body) do
      # Parse the SOAP request to extract the message
      case Lather.Xml.Parser.parse(body) do
        {:ok, parsed} ->
          envelope = parsed["soap:Envelope"] || parsed["Envelope"] || %{}
          body_content = envelope["soap:Body"] || envelope["Body"] || %{}

          # Extract the operation - look for SecureOperation
          operation = body_content["SecureOperation"] || body_content["tns:SecureOperation"] || %{}
          message = operation["message"] || ""

          # Return a successful SOAP response
          response_xml = """
          <?xml version="1.0" encoding="UTF-8"?>
          <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
            <soap:Body>
              <SecureOperationResponse xmlns="http://test.example.com/secure">
                <result>Authenticated: #{escape_xml(message)}</result>
              </SecureOperationResponse>
            </soap:Body>
          </soap:Envelope>
          """

          conn
          |> Plug.Conn.put_resp_content_type("text/xml")
          |> Plug.Conn.send_resp(200, response_xml)

        {:error, _reason} ->
          send_soap_fault(conn, "Client", "InvalidRequest", "Failed to parse SOAP request")
      end
    end

    defp escape_xml(text) when is_binary(text) do
      text
      |> String.replace("&", "&amp;")
      |> String.replace("<", "&lt;")
      |> String.replace(">", "&gt;")
    end

    defp escape_xml(_), do: ""

    defp validate_ws_security(body, mode, opts) do
      case Lather.Xml.Parser.parse(body) do
        {:ok, parsed} ->
          security = extract_security_header(parsed)
          validate_security(security, mode, opts)

        {:error, reason} ->
          {:error, {:parse_error, reason}}
      end
    end

    defp extract_security_header(parsed) do
      # Try different paths to find the Security header
      envelope = parsed["soap:Envelope"] || parsed["Envelope"] || %{}
      header = envelope["soap:Header"] || envelope["Header"]

      # Handle case where header might be nil or empty string
      case header do
        nil -> nil
        "" -> nil
        header when is_map(header) ->
          # Security can be under wsse:Security or just Security
          header["wsse:Security"] || header["Security"] || nil
        _ -> nil
      end
    end

    defp validate_security(nil, :no_auth, _opts), do: {:ok, :no_auth_required}
    defp validate_security(nil, _mode, _opts), do: {:error, :missing_security_header}

    defp validate_security(security, :text_password, opts) do
      expected_username = Keyword.get(opts, :username, "admin")
      expected_password = Keyword.get(opts, :password, "secret123")

      username_token = security["wsse:UsernameToken"] || security["UsernameToken"] || %{}
      username = username_token["wsse:Username"] || username_token["Username"]
      password_elem = username_token["wsse:Password"] || username_token["Password"] || %{}

      password = extract_password_text(password_elem)
      password_type = extract_password_type(password_elem)

      cond do
        username != expected_username ->
          {:error, :invalid_credentials}

        password != expected_password ->
          {:error, :invalid_credentials}

        password_type && !String.contains?(password_type, "PasswordText") ->
          {:error, :invalid_password_type}

        true ->
          {:ok, %{username: username, password_type: :text}}
      end
    end

    defp validate_security(security, :digest_password, opts) do
      expected_username = Keyword.get(opts, :username, "admin")
      expected_password = Keyword.get(opts, :password, "secret123")

      username_token = security["wsse:UsernameToken"] || security["UsernameToken"] || %{}
      username = username_token["wsse:Username"] || username_token["Username"]
      password_elem = username_token["wsse:Password"] || username_token["Password"] || %{}
      nonce_elem = username_token["wsse:Nonce"] || username_token["Nonce"] || %{}
      created = username_token["wsu:Created"] || username_token["Created"]

      password_digest = extract_password_text(password_elem)
      password_type = extract_password_type(password_elem)
      nonce = extract_nonce(nonce_elem)

      cond do
        username != expected_username ->
          {:error, :invalid_credentials}

        password_type && !String.contains?(password_type, "PasswordDigest") ->
          {:error, :invalid_password_type}

        !verify_password_digest(password_digest, expected_password, nonce, created) ->
          {:error, :invalid_password_digest}

        true ->
          {:ok, %{username: username, password_type: :digest}}
      end
    end

    defp validate_security(security, :timestamp_only, opts) do
      timestamp = security["wsu:Timestamp"] || security["Timestamp"] || %{}
      validate_timestamp(timestamp, opts)
    end

    defp validate_security(security, :username_with_timestamp, opts) do
      # First validate credentials
      case validate_security(security, :text_password, opts) do
        {:ok, cred_info} ->
          # Then validate timestamp
          timestamp = security["wsu:Timestamp"] || security["Timestamp"] || %{}

          case validate_timestamp(timestamp, opts) do
            {:ok, ts_info} ->
              {:ok, Map.merge(cred_info, ts_info)}

            error ->
              error
          end

        error ->
          error
      end
    end

    defp validate_security(security, :require_timestamp, opts) do
      timestamp = security["wsu:Timestamp"] || security["Timestamp"]

      if timestamp do
        validate_timestamp(timestamp, opts)
      else
        {:error, :missing_timestamp}
      end
    end

    defp validate_timestamp(nil, _opts), do: {:error, :missing_timestamp}

    defp validate_timestamp(timestamp, opts) do
      created = timestamp["wsu:Created"] || timestamp["Created"]
      expires = timestamp["wsu:Expires"] || timestamp["Expires"]

      # Check if we should reject expired timestamps
      reject_expired = Keyword.get(opts, :reject_expired, true)

      cond do
        is_nil(created) ->
          {:error, :invalid_timestamp}

        is_nil(expires) ->
          {:error, :invalid_timestamp}

        reject_expired && timestamp_expired?(expires) ->
          {:error, :timestamp_expired}

        true ->
          {:ok, %{created: created, expires: expires}}
      end
    end

    defp timestamp_expired?(expires_str) do
      case DateTime.from_iso8601(expires_str) do
        {:ok, expires_dt, _offset} ->
          DateTime.compare(DateTime.utc_now(), expires_dt) == :gt

        _ ->
          true
      end
    end

    defp extract_password_text(password_elem) when is_binary(password_elem), do: password_elem
    defp extract_password_text(%{"#text" => text}), do: text
    defp extract_password_text(_), do: nil

    defp extract_password_type(%{"@Type" => type}), do: type
    defp extract_password_type(_), do: nil

    defp extract_nonce(nonce_elem) when is_binary(nonce_elem), do: nonce_elem
    defp extract_nonce(%{"#text" => text}), do: text
    defp extract_nonce(_), do: nil

    defp verify_password_digest(digest, password, nonce, created)
         when is_binary(digest) and is_binary(nonce) and is_binary(created) do
      # Compute expected digest: Base64(SHA1(nonce + created + password))
      case Base.decode64(nonce) do
        {:ok, nonce_decoded} ->
          digest_input = nonce_decoded <> created <> password
          expected_digest = :crypto.hash(:sha, digest_input) |> Base.encode64()
          digest == expected_digest

        :error ->
          false
      end
    end

    defp verify_password_digest(_, _, _, _), do: false

    defp send_soap_fault(conn, fault_code, subcode, fault_string) do
      fault_xml = """
      <?xml version="1.0" encoding="UTF-8"?>
      <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
                     xmlns:wsse="#{@wsse_namespace}">
        <soap:Body>
          <soap:Fault>
            <faultcode>#{fault_code}</faultcode>
            <faultstring>#{fault_string}</faultstring>
            <detail>
              <wsse:SecurityFault>#{subcode}</wsse:SecurityFault>
            </detail>
          </soap:Fault>
        </soap:Body>
      </soap:Envelope>
      """

      conn
      |> Plug.Conn.put_resp_content_type("text/xml")
      |> Plug.Conn.send_resp(500, fault_xml)
    end
  end

  describe "UsernameToken with text password" do
    setup do
      start_test_server(:text_password, username: @valid_username, password: @valid_password)
    end

    test "client sends text password, server receives and validates", %{base_url: base_url} do
      # Build a SOAP request with WS-Security header
      security_header = WSSecurity.username_token(@valid_username, @valid_password, password_type: :text)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Hello Secure World"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      # Send the request
      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
      assert String.contains?(response.body, "Authenticated: Hello Secure World")
    end

    test "validates username is correctly transmitted", %{base_url: base_url} do
      security_header = WSSecurity.username_token(@valid_username, @valid_password)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end

    test "validates password is correctly transmitted", %{base_url: base_url} do
      security_header = WSSecurity.username_token(@valid_username, @valid_password)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end

    test "header includes correct password type attribute" do
      token = WSSecurity.username_token(@valid_username, @valid_password, password_type: :text)

      password_elem = get_in(token, ["wsse:Security", "wsse:UsernameToken", "wsse:Password"])

      assert password_elem["@Type"] == @password_text_type
    end

    test "header includes wsu:Created element by default" do
      token = WSSecurity.username_token(@valid_username, @valid_password)

      created = get_in(token, ["wsse:Security", "wsse:UsernameToken", "wsu:Created"])

      assert is_binary(created)
      assert {:ok, _, _} = DateTime.from_iso8601(created)
    end
  end

  describe "UsernameToken with digest password" do
    setup do
      start_test_server(:digest_password, username: @valid_username, password: @valid_password)
    end

    test "client sends digest password, server validates digest", %{base_url: base_url} do
      security_header = WSSecurity.username_token(
        @valid_username,
        @valid_password,
        password_type: :digest
      )

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Digest Auth Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
      assert String.contains?(response.body, "Authenticated: Digest Auth Test")
    end

    test "digest includes nonce element" do
      token = WSSecurity.username_token(@valid_username, @valid_password, password_type: :digest)

      nonce_elem = get_in(token, ["wsse:Security", "wsse:UsernameToken", "wsse:Nonce"])

      assert is_map(nonce_elem)
      assert Map.has_key?(nonce_elem, "#text")
      assert Map.has_key?(nonce_elem, "@EncodingType")
      assert String.contains?(nonce_elem["@EncodingType"], "Base64Binary")
    end

    test "digest includes created timestamp" do
      token = WSSecurity.username_token(@valid_username, @valid_password, password_type: :digest)

      created = get_in(token, ["wsse:Security", "wsse:UsernameToken", "wsu:Created"])

      assert is_binary(created)
    end

    test "password digest type attribute is correct" do
      token = WSSecurity.username_token(@valid_username, @valid_password, password_type: :digest)

      password_elem = get_in(token, ["wsse:Security", "wsse:UsernameToken", "wsse:Password"])

      assert password_elem["@Type"] == @password_digest_type
    end

    test "different nonces produce different digests" do
      token1 = WSSecurity.username_token(@valid_username, @valid_password, password_type: :digest)
      token2 = WSSecurity.username_token(@valid_username, @valid_password, password_type: :digest)

      digest1 = get_in(token1, ["wsse:Security", "wsse:UsernameToken", "wsse:Password", "#text"])
      digest2 = get_in(token2, ["wsse:Security", "wsse:UsernameToken", "wsse:Password", "#text"])

      # Digests should be different because nonces are different
      refute digest1 == digest2
    end
  end

  describe "Timestamp headers" do
    setup do
      start_test_server(:timestamp_only, reject_expired: true)
    end

    test "Created/Expires validation with valid timestamp", %{base_url: base_url} do
      timestamp_header = WSSecurity.timestamp(ttl: 300)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Timestamp Test"},
        headers: [timestamp_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end

    test "timestamp includes Created element" do
      timestamp = WSSecurity.timestamp()

      created = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Created"])

      assert is_binary(created)
      assert {:ok, _, _} = DateTime.from_iso8601(created)
    end

    test "timestamp includes Expires element" do
      timestamp = WSSecurity.timestamp()

      expires = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Expires"])

      assert is_binary(expires)
      assert {:ok, _, _} = DateTime.from_iso8601(expires)
    end

    test "Expires is after Created" do
      timestamp = WSSecurity.timestamp(ttl: 300)

      created_str = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Created"])
      expires_str = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Expires"])

      {:ok, created, _} = DateTime.from_iso8601(created_str)
      {:ok, expires, _} = DateTime.from_iso8601(expires_str)

      assert DateTime.compare(expires, created) == :gt
    end

    test "TTL is respected" do
      timestamp = WSSecurity.timestamp(ttl: 600)

      created_str = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Created"])
      expires_str = get_in(timestamp, ["wsse:Security", "wsu:Timestamp", "wsu:Expires"])

      {:ok, created, _} = DateTime.from_iso8601(created_str)
      {:ok, expires, _} = DateTime.from_iso8601(expires_str)

      diff = DateTime.diff(expires, created)
      assert diff == 600
    end
  end

  describe "Combined UsernameToken + Timestamp" do
    setup do
      start_test_server(:username_with_timestamp, username: @valid_username, password: @valid_password)
    end

    test "combined header is validated correctly", %{base_url: base_url} do
      combined_header = WSSecurity.username_token_with_timestamp(
        @valid_username,
        @valid_password,
        ttl: 300
      )

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Combined Test"},
        headers: [combined_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
      assert String.contains?(response.body, "Authenticated: Combined Test")
    end

    test "combined header includes both UsernameToken and Timestamp" do
      combined = WSSecurity.username_token_with_timestamp(@valid_username, @valid_password)

      security = combined["wsse:Security"]

      assert Map.has_key?(security, "wsse:UsernameToken")
      assert Map.has_key?(security, "wsu:Timestamp")
    end

    test "UsernameToken has unique ID" do
      combined = WSSecurity.username_token_with_timestamp(@valid_username, @valid_password)

      username_token = get_in(combined, ["wsse:Security", "wsse:UsernameToken"])

      assert Map.has_key?(username_token, "@wsu:Id")
      assert String.starts_with?(username_token["@wsu:Id"], "UsernameToken-")
    end

    test "Timestamp has unique ID" do
      combined = WSSecurity.username_token_with_timestamp(@valid_username, @valid_password)

      timestamp = get_in(combined, ["wsse:Security", "wsu:Timestamp"])

      assert Map.has_key?(timestamp, "@wsu:Id")
      assert String.starts_with?(timestamp["@wsu:Id"], "Timestamp-")
    end

    test "combined header with digest password" do
      combined = WSSecurity.username_token_with_timestamp(
        @valid_username,
        @valid_password,
        password_type: :digest
      )

      password_elem = get_in(combined, ["wsse:Security", "wsse:UsernameToken", "wsse:Password"])

      assert String.contains?(password_elem["@Type"], "PasswordDigest")
    end
  end

  describe "Invalid credentials rejection" do
    setup do
      start_test_server(:text_password, username: @valid_username, password: @valid_password)
    end

    test "wrong username is rejected", %{base_url: base_url} do
      security_header = WSSecurity.username_token("wrong_user", @valid_password)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 500
      assert String.contains?(response.body, "FailedAuthentication") or
             String.contains?(response.body, "invalid")
    end

    test "wrong password is rejected", %{base_url: base_url} do
      security_header = WSSecurity.username_token(@valid_username, "wrong_password")

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 500
      assert String.contains?(response.body, "FailedAuthentication") or
             String.contains?(response.body, "invalid")
    end

    test "wrong digest password is rejected", %{base_url: _base_url, server_pid: server_pid} do
      # Stop the current server and start one expecting digest
      GenServer.stop(server_pid, :normal, 1000)
      Process.sleep(50)

      {:ok, port, new_server_pid} = start_server(:digest_password, username: @valid_username, password: @valid_password)

      # Create a digest with wrong password
      security_header = WSSecurity.username_token(
        @valid_username,
        "wrong_password",
        password_type: :digest
      )

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request("http://localhost:#{port}/soap", envelope)

      assert response.status == 500
      assert String.contains?(response.body, "FailedAuthentication") or
             String.contains?(response.body, "digest")

      GenServer.stop(new_server_pid, :normal, 1000)
    end
  end

  describe "Missing security header rejection" do
    setup do
      start_test_server(:text_password, username: @valid_username, password: @valid_password)
    end

    test "request without security header is rejected", %{base_url: base_url} do
      # Build envelope without security headers
      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "No Auth"},
        headers: [],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 500
      assert String.contains?(response.body, "Security") or
             String.contains?(response.body, "required")
    end

    test "request with empty security header is rejected", %{base_url: base_url} do
      # Build envelope with empty security header
      empty_security = %{
        "wsse:Security" => %{
          "@xmlns:wsse" => @wsse_ns,
          "@xmlns:wsu" => @wsu_ns
        }
      }

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Empty Auth"},
        headers: [empty_security],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 500
    end
  end

  describe "Expired timestamp rejection" do
    setup do
      start_test_server(:require_timestamp, reject_expired: true)
    end

    test "expired timestamp is rejected", %{base_url: base_url} do
      # Create a timestamp that's already expired
      now = DateTime.utc_now()
      created = DateTime.add(now, -120, :second)  # 2 minutes ago
      expires = DateTime.add(now, -60, :second)   # 1 minute ago (expired)

      expired_timestamp = %{
        "wsse:Security" => %{
          "@xmlns:wsse" => @wsse_ns,
          "@xmlns:wsu" => @wsu_ns,
          "wsu:Timestamp" => %{
            "wsu:Created" => DateTime.to_iso8601(created),
            "wsu:Expires" => DateTime.to_iso8601(expires)
          }
        }
      }

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Expired Test"},
        headers: [expired_timestamp],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 500
      assert String.contains?(response.body, "Expired") or
             String.contains?(response.body, "expired")
    end

    test "valid timestamp is accepted", %{base_url: base_url} do
      timestamp_header = WSSecurity.timestamp(ttl: 300)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Valid Timestamp"},
        headers: [timestamp_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end
  end

  describe "Header merging with Lather.Soap.Header" do
    setup do
      start_test_server(:username_with_timestamp, username: @valid_username, password: @valid_password)
    end

    test "Header.username_token produces same structure as WSSecurity.username_token" do
      ws_token = WSSecurity.username_token("user", "pass")
      header_token = Header.username_token("user", "pass")

      assert Map.keys(ws_token) == Map.keys(header_token)
      assert Map.has_key?(ws_token["wsse:Security"], "wsse:UsernameToken")
      assert Map.has_key?(header_token["wsse:Security"], "wsse:UsernameToken")
    end

    test "Header.timestamp produces same structure as WSSecurity.timestamp" do
      ws_ts = WSSecurity.timestamp()
      header_ts = Header.timestamp()

      assert Map.keys(ws_ts) == Map.keys(header_ts)
      assert Map.has_key?(ws_ts["wsse:Security"], "wsu:Timestamp")
      assert Map.has_key?(header_ts["wsse:Security"], "wsu:Timestamp")
    end

    test "Header.merge_headers combines multiple headers" do
      username_header = Header.username_token(@valid_username, @valid_password)
      session_header = Header.session("session-12345")

      merged = Header.merge_headers([username_header, session_header])

      assert Map.has_key?(merged, "wsse:Security")
      assert Map.has_key?(merged, "SessionId")
    end

    test "Headers from Header module work in actual request", %{base_url: base_url} do
      combined_header = Header.username_token_with_timestamp(
        @valid_username,
        @valid_password,
        ttl: 300
      )

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Header Module Test"},
        headers: [combined_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end
  end

  describe "WS-Security namespace handling" do
    setup do
      start_test_server(:text_password, username: @valid_username, password: @valid_password)
    end

    test "security header includes correct wsse namespace" do
      token = WSSecurity.username_token(@valid_username, @valid_password)

      assert token["wsse:Security"]["@xmlns:wsse"] == @wsse_ns
    end

    test "security header includes correct wsu namespace" do
      token = WSSecurity.username_token(@valid_username, @valid_password)

      assert token["wsse:Security"]["@xmlns:wsu"] == @wsu_ns
    end

    test "namespaces are preserved in XML output" do
      token = WSSecurity.username_token(@valid_username, @valid_password)

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "TestOp",
        %{},
        headers: [token]
      )

      assert String.contains?(envelope, "xmlns:wsse=")
      assert String.contains?(envelope, "xmlns:wsu=")
    end
  end

  describe "Special characters handling" do
    setup do
      start_test_server(:text_password, username: "user@domain.com", password: "p@ss&word<>\"'")
    end

    test "special characters in username are handled", %{base_url: base_url} do
      security_header = WSSecurity.username_token("user@domain.com", "p@ss&word<>\"'")

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "SecureOperation",
        %{"message" => "Special chars test"},
        headers: [security_header],
        namespace: "http://test.example.com/secure"
      )

      {:ok, response} = make_soap_request(base_url, envelope)

      assert response.status == 200
    end

    test "special characters in password are escaped in XML" do
      security_header = WSSecurity.username_token("user", "pass<>&\"'")

      {:ok, envelope} = Lather.Soap.Envelope.build(
        "TestOp",
        %{},
        headers: [security_header]
      )

      # Verify XML escaping - at least < and > should be escaped
      assert String.contains?(envelope, "&lt;") or String.contains?(envelope, "&gt;")
    end
  end

  # Helper functions

  defp start_test_server(validation_mode, opts) do
    {:ok, _} = Application.ensure_all_started(:lather)

    {:ok, port, server_pid} = start_server(validation_mode, opts)

    on_exit(fn ->
      try do
        GenServer.stop(server_pid, :normal, 1000)
      catch
        :exit, _ -> :ok
      end
    end)

    Process.sleep(50)

    {:ok, port: port, base_url: "http://localhost:#{port}/soap", server_pid: server_pid}
  end

  defp start_server(validation_mode, opts) do
    port = Enum.random(10000..60000)

    # Set up validation mode using ETS (accessible across processes)
    ValidationConfig.set(validation_mode, opts)

    {:ok, server_pid} = Bandit.start_link(plug: TestSecurityRouter, port: port, scheme: :http)

    {:ok, port, server_pid}
  end

  defp make_soap_request(url, body) do
    # Use Finch directly for HTTP requests
    request = Finch.build(:post, url, [{"content-type", "text/xml; charset=utf-8"}], body)

    case Finch.request(request, Lather.Finch) do
      {:ok, response} ->
        {:ok, %{status: response.status, body: response.body, headers: response.headers}}

      {:error, reason} ->
        {:error, reason}
    end
  end
end
