# Getting Started with Lather SOAP Library

```elixir
Mix.install([
  # {:lather, path: ".."}, # For local development
  {:lather, github: "awksedgreep/lather"}, # Use GitHub until 1.0.6 is on hex
  {:bandit, "~> 1.0"},
  {:kino, "~> 0.12"}
])
```

## Introduction

Welcome to the **Lather SOAP Library** interactive tutorial! Lather is a full-featured SOAP library for Elixir that supports both client and server functionality.

In this Livebook, you'll learn:

* How to create a SOAP server with Lather
* How to connect to SOAP services using WSDL
* Making SOAP calls with dynamic parameters
* Handling responses and errors

<!-- livebook:{"break_markdown":true} -->

## Creating a SOAP Server

First, let's define a simple Calculator SOAP service that we'll use throughout this tutorial:

```elixir
defmodule CalculatorService do
  use Lather.Server

  @namespace "http://example.com/calculator"
  @service_name "CalculatorService"

  soap_operation "Add" do
    description "Adds two numbers together"

    input do
      parameter "a", :decimal, required: true, description: "First number"
      parameter "b", :decimal, required: true, description: "Second number"
    end

    output do
      parameter "result", :decimal, description: "Sum of a and b"
    end

    soap_action "Add"
  end

  def add(%{"a" => a, "b" => b}) do
    num_a = parse_number(a)
    num_b = parse_number(b)
    {:ok, %{"result" => num_a + num_b}}
  end

  soap_operation "Subtract" do
    description "Subtracts the second number from the first"

    input do
      parameter "a", :decimal, required: true
      parameter "b", :decimal, required: true
    end

    output do
      parameter "result", :decimal
    end

    soap_action "Subtract"
  end

  def subtract(%{"a" => a, "b" => b}) do
    {:ok, %{"result" => parse_number(a) - parse_number(b)}}
  end

  soap_operation "Multiply" do
    description "Multiplies two numbers"

    input do
      parameter "a", :decimal, required: true
      parameter "b", :decimal, required: true
    end

    output do
      parameter "result", :decimal
    end

    soap_action "Multiply"
  end

  def multiply(%{"a" => a, "b" => b}) do
    {:ok, %{"result" => parse_number(a) * parse_number(b)}}
  end

  soap_operation "Divide" do
    description "Divides the first number by the second"

    input do
      parameter "dividend", :decimal, required: true
      parameter "divisor", :decimal, required: true
    end

    output do
      parameter "quotient", :decimal
    end

    soap_action "Divide"
  end

  def divide(%{"dividend" => dividend, "divisor" => divisor}) do
    d = parse_number(divisor)

    if d == 0 do
      Lather.Server.soap_fault("Client", "Division by zero is not allowed")
    else
      {:ok, %{"quotient" => parse_number(dividend) / d}}
    end
  end

  defp parse_number(val) when is_number(val), do: val
  defp parse_number(val) when is_binary(val) do
    case Float.parse(val) do
      {num, _} -> num
      :error -> String.to_integer(val)
    end
  end
end

IO.puts("Calculator service module defined!")
```

## Starting the SOAP Server

Now let's start our Calculator service on a local port:

```elixir
# Start required applications
{:ok, _} = Application.ensure_all_started(:lather)
{:ok, _} = Application.ensure_all_started(:bandit)

# Define a simple Plug router for our service
defmodule CalculatorRouter do
  use Plug.Router

  plug :match
  plug :dispatch

  # Handle WSDL and SOAP requests
  match "/calculator" do
    Lather.Server.Plug.call(conn, Lather.Server.Plug.init(service: CalculatorService))
  end

  match _ do
    send_resp(conn, 404, "Not found")
  end
end

# Stop any existing server on this port
case Process.whereis(:calculator_server) do
  nil -> :ok
  pid -> Supervisor.stop(pid)
end

# Start the server
{:ok, pid} = Bandit.start_link(plug: CalculatorRouter, port: 4040, scheme: :http)
Process.register(pid, :calculator_server)

IO.puts("Calculator SOAP server started on http://localhost:4040/calculator")
IO.puts("WSDL available at: http://localhost:4040/calculator?wsdl")
```

## Connecting as a SOAP Client

Now let's connect to our own service using the DynamicClient:

```elixir
# Create a dynamic client from the WSDL
wsdl_url = "http://localhost:4040/calculator?wsdl"

case Lather.DynamicClient.new(wsdl_url, timeout: 30_000) do
  {:ok, client} ->
    IO.puts("Successfully connected to Calculator service!")

    # Store the client for use in other cells
    Process.put(:calculator_client, client)

    # Show available operations
    operations = Lather.DynamicClient.list_operations(client)
    IO.puts("\nAvailable operations:")
    Enum.each(operations, fn op -> IO.puts("   #{op}") end)

    client

  {:error, error} ->
    IO.puts("Failed to connect: #{inspect(error)}")
    nil
end
```

## Exploring Service Operations

Let's examine the details of available operations:

```elixir
client = Process.get(:calculator_client)

if client do
  # Get detailed information about an operation
  case Lather.DynamicClient.get_operation_info(client, "Add") do
    {:ok, info} ->
      IO.puts("Operation: Add")
      IO.puts("\nInput Parameters:")

      Enum.each(info.input_parts, fn part ->
        required = if part.required, do: " (required)", else: " (optional)"
        IO.puts("   #{part.name}: #{part.type}#{required}")
      end)

      IO.puts("\nOutput:")
      Enum.each(info.output_parts, fn part ->
        IO.puts("   #{part.name}: #{part.type}")
      end)

      if info.soap_action do
        IO.puts("\nSOAP Action: #{info.soap_action}")
      end

    {:error, error} ->
      IO.puts("Error getting operation info: #{inspect(error)}")
  end
else
  IO.puts("No client available. Run the connection cell first.")
end
```

## Making Your First SOAP Call

Now let's make actual SOAP calls to our calculator service:

```elixir
client = Process.get(:calculator_client)

if client do
  IO.puts("Testing Calculator Operations\n")

  # Test Add
  IO.puts("1. Add: 10 + 5")
  case Lather.DynamicClient.call(client, "Add", %{"a" => 10, "b" => 5}) do
    {:ok, response} ->
      IO.puts("   Result: #{response["result"]}")
    {:error, error} ->
      IO.puts("   Error: #{inspect(error)}")
  end

  # Test Subtract
  IO.puts("\n2. Subtract: 100 - 37")
  case Lather.DynamicClient.call(client, "Subtract", %{"a" => 100, "b" => 37}) do
    {:ok, response} ->
      IO.puts("   Result: #{response["result"]}")
    {:error, error} ->
      IO.puts("   Error: #{inspect(error)}")
  end

  # Test Multiply
  IO.puts("\n3. Multiply: 7 * 8")
  case Lather.DynamicClient.call(client, "Multiply", %{"a" => 7, "b" => 8}) do
    {:ok, response} ->
      IO.puts("   Result: #{response["result"]}")
    {:error, error} ->
      IO.puts("   Error: #{inspect(error)}")
  end

  # Test Divide
  IO.puts("\n4. Divide: 100 / 4")
  case Lather.DynamicClient.call(client, "Divide", %{"dividend" => 100, "divisor" => 4}) do
    {:ok, response} ->
      IO.puts("   Result: #{response["quotient"]}")
    {:error, error} ->
      IO.puts("   Error: #{inspect(error)}")
  end
else
  IO.puts("No client available. Run the connection cell first.")
end
```

## Interactive Calculator

Let's create an interactive calculator widget:

```elixir
# Create input widgets
a_input = Kino.Input.number("First Number (a)", default: 10)
b_input = Kino.Input.number("Second Number (b)", default: 5)
operation_input = Kino.Input.select("Operation", [
  {"Add", "Add"},
  {"Subtract", "Subtract"},
  {"Multiply", "Multiply"},
  {"Divide", "Divide"}
])
calculate_button = Kino.Control.button("Calculate")

# Layout the inputs
form = Kino.Layout.grid([
  [a_input, b_input],
  [operation_input],
  [calculate_button]
])

form
```

```elixir
# Handle the button click
client = Process.get(:calculator_client)

Kino.Control.stream(calculate_button)
|> Kino.listen(fn _event ->
  if client do
    a = Kino.Input.read(a_input)
    b = Kino.Input.read(b_input)
    operation = Kino.Input.read(operation_input)

    params = case operation do
      "Divide" -> %{"dividend" => a, "divisor" => b}
      _ -> %{"a" => a, "b" => b}
    end

    IO.puts("Calculating: #{operation}(#{a}, #{b})")

    case Lather.DynamicClient.call(client, operation, params) do
      {:ok, response} ->
        result = response["result"] || response["quotient"]
        IO.puts("Result: #{result}")
      {:error, error} ->
        IO.puts("Error: #{inspect(error)}")
    end
  else
    IO.puts("Calculator client not available")
  end
end)

:ok
```

## Error Handling Examples

Let's explore how Lather handles different types of errors:

```elixir
client = Process.get(:calculator_client)

if client do
  IO.puts("Testing Error Scenarios\n")

  # Test 1: Division by zero (SOAP fault from server)
  IO.puts("1. Division by zero:")
  case Lather.DynamicClient.call(client, "Divide", %{"dividend" => 100, "divisor" => 0}) do
    {:ok, response} ->
      IO.puts("   Unexpected success: #{inspect(response)}")
    {:error, error} ->
      IO.puts("   Expected error: #{error.type}")
      IO.puts("   Message: #{error.message || inspect(error)}")
  end

  # Test 2: Invalid operation name
  IO.puts("\n2. Invalid operation name:")
  case Lather.DynamicClient.call(client, "NonExistentOperation", %{}) do
    {:ok, _response} ->
      IO.puts("   Unexpected success")
    {:error, error} ->
      IO.puts("   Expected error: #{error.type}")
      IO.puts("   Message: #{error.message}")
  end

  # Test 3: Missing required parameters
  IO.puts("\n3. Missing required parameters:")
  case Lather.DynamicClient.call(client, "Add", %{}) do
    {:ok, response} ->
      IO.puts("   Response: #{inspect(response)}")
    {:error, error} ->
      IO.puts("   Error: #{error.type}")
      IO.puts("   Details: #{inspect(error.details || error.message)}")
  end
else
  IO.puts("No client available")
end
```

## Performance: Concurrent Requests

Let's see how Lather handles multiple concurrent requests:

```elixir
client = Process.get(:calculator_client)

if client do
  # List of calculations to perform
  calculations = [
    {"Add", %{"a" => 10, "b" => 20}},
    {"Subtract", %{"a" => 100, "b" => 45}},
    {"Multiply", %{"a" => 7, "b" => 8}},
    {"Divide", %{"dividend" => 144, "divisor" => 12}},
    {"Add", %{"a" => 1000, "b" => 2000}}
  ]

  IO.puts("Making #{length(calculations)} concurrent requests...")
  start_time = System.monotonic_time(:millisecond)

  # Create async tasks for each calculation
  tasks = Enum.map(calculations, fn {operation, params} ->
    Task.async(fn ->
      result = Lather.DynamicClient.call(client, operation, params)
      {operation, params, result}
    end)
  end)

  # Wait for all tasks to complete
  results = Task.await_many(tasks, 30_000)
  end_time = System.monotonic_time(:millisecond)

  IO.puts("\nResults (completed in #{end_time - start_time}ms):\n")

  Enum.each(results, fn {operation, params, result} ->
    case result do
      {:ok, response} ->
        value = response["result"] || response["quotient"]
        IO.puts("   #{operation}: #{inspect(params)} = #{value}")
      {:error, error} ->
        IO.puts("   #{operation}: Error - #{inspect(error)}")
    end
  end)

  success_count = Enum.count(results, fn {_, _, result} -> match?({:ok, _}, result) end)
  IO.puts("\nSummary: #{success_count}/#{length(calculations)} requests successful")
else
  IO.puts("No client available")
end
```

## Service Information Summary

Let's examine the full service metadata:

```elixir
client = Process.get(:calculator_client)

if client do
  service_info = client.service_info

  IO.puts("SOAP Service Summary")
  IO.puts(String.duplicate("=", 50))

  IO.puts("Service Name: #{service_info.name}")
  IO.puts("Namespace: #{service_info.namespace}")

  # Service endpoints
  if service_info.services && length(service_info.services) > 0 do
    service = hd(service_info.services)
    IO.puts("Endpoint: #{service[:endpoint] || "N/A"}")
  end

  # Operations
  IO.puts("\nAvailable Operations (#{length(service_info.operations)}):")
  Enum.each(service_info.operations, fn op ->
    input_count = length(op.input_parts || op.input || [])
    output_count = length(op.output_parts || op.output || [])
    IO.puts("   #{op.name} (#{input_count} inputs, #{output_count} outputs)")
  end)
else
  IO.puts("No service information available")
end
```

## Cleanup

Stop the server when done:

```elixir
case Process.whereis(:calculator_server) do
  nil ->
    IO.puts("Server already stopped")
  pid ->
    Supervisor.stop(pid)
    IO.puts("Server stopped")
end
```

## Next Steps

Congratulations! You've learned the basics of using the Lather SOAP library for both server and client functionality.

Here's what you can explore next:

1. **Enhanced Server**: Check out `Lather.Server.EnhancedPlug` for web forms and multi-protocol support
2. **Authentication**: Add WS-Security or Basic Auth to your services
3. **Complex Types**: Define custom types with `soap_type` for structured data
4. **MTOM Attachments**: Handle binary data with MTOM support

## Quick Reference

```elixir
reference = """
LATHER SOAP LIBRARY - QUICK REFERENCE

SERVER SIDE:
   defmodule MyService do
     use Lather.Server
     @namespace "http://example.com/myservice"
     @service_name "MyService"

     soap_operation "MyOp" do
       input do
         parameter "param1", :string, required: true
       end
       output do
         parameter "result", :string
       end
     end

     def my_op(%{"param1" => val}), do: {:ok, %{"result" => val}}
   end

CLIENT SIDE:
   {:ok, client} = Lather.DynamicClient.new(wsdl_url)
   operations = Lather.DynamicClient.list_operations(client)
   {:ok, info} = Lather.DynamicClient.get_operation_info(client, "OpName")
   {:ok, response} = Lather.DynamicClient.call(client, "OpName", params)

ERROR HANDLING:
   case result do
     {:ok, response} -> # Success
     {:error, %{type: :soap_fault}} -> # SOAP fault
     {:error, %{type: :http_error}} -> # HTTP error
     {:error, %{type: :transport_error}} -> # Network error
   end
"""

IO.puts(reference)
```

Happy SOAP-ing with Lather!
